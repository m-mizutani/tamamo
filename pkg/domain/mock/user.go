// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/m-mizutani/tamamo/pkg/domain/interfaces"
	"github.com/m-mizutani/tamamo/pkg/domain/model/user"
	"github.com/m-mizutani/tamamo/pkg/domain/types"
	"sync"
)

// Ensure, that UserUseCasesMock does implement interfaces.UserUseCases.
// If this is not the case, regenerate this file with moq.
var _ interfaces.UserUseCases = &UserUseCasesMock{}

// UserUseCasesMock is a mock implementation of interfaces.UserUseCases.
//
//	func TestSomethingThatUsesUserUseCases(t *testing.T) {
//
//		// make and configure a mocked interfaces.UserUseCases
//		mockedUserUseCases := &UserUseCasesMock{
//			GetOrCreateUserFunc: func(ctx context.Context, slackID string, slackName string, email string, teamID string) (*user.User, error) {
//				panic("mock out the GetOrCreateUser method")
//			},
//			GetUserAvatarFunc: func(ctx context.Context, userID types.UserID, size int) ([]byte, error) {
//				panic("mock out the GetUserAvatar method")
//			},
//			GetUserByIDFunc: func(ctx context.Context, userID types.UserID) (*user.User, error) {
//				panic("mock out the GetUserByID method")
//			},
//			InvalidateUserAvatarCacheFunc: func(ctx context.Context, userID types.UserID) error {
//				panic("mock out the InvalidateUserAvatarCache method")
//			},
//			UpdateUserFunc: func(ctx context.Context, userMoqParam *user.User) error {
//				panic("mock out the UpdateUser method")
//			},
//		}
//
//		// use mockedUserUseCases in code that requires interfaces.UserUseCases
//		// and then make assertions.
//
//	}
type UserUseCasesMock struct {
	// GetOrCreateUserFunc mocks the GetOrCreateUser method.
	GetOrCreateUserFunc func(ctx context.Context, slackID string, slackName string, email string, teamID string) (*user.User, error)

	// GetUserAvatarFunc mocks the GetUserAvatar method.
	GetUserAvatarFunc func(ctx context.Context, userID types.UserID, size int) ([]byte, error)

	// GetUserByIDFunc mocks the GetUserByID method.
	GetUserByIDFunc func(ctx context.Context, userID types.UserID) (*user.User, error)

	// InvalidateUserAvatarCacheFunc mocks the InvalidateUserAvatarCache method.
	InvalidateUserAvatarCacheFunc func(ctx context.Context, userID types.UserID) error

	// UpdateUserFunc mocks the UpdateUser method.
	UpdateUserFunc func(ctx context.Context, userMoqParam *user.User) error

	// calls tracks calls to the methods.
	calls struct {
		// GetOrCreateUser holds details about calls to the GetOrCreateUser method.
		GetOrCreateUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SlackID is the slackID argument value.
			SlackID string
			// SlackName is the slackName argument value.
			SlackName string
			// Email is the email argument value.
			Email string
			// TeamID is the teamID argument value.
			TeamID string
		}
		// GetUserAvatar holds details about calls to the GetUserAvatar method.
		GetUserAvatar []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID types.UserID
			// Size is the size argument value.
			Size int
		}
		// GetUserByID holds details about calls to the GetUserByID method.
		GetUserByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID types.UserID
		}
		// InvalidateUserAvatarCache holds details about calls to the InvalidateUserAvatarCache method.
		InvalidateUserAvatarCache []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID types.UserID
		}
		// UpdateUser holds details about calls to the UpdateUser method.
		UpdateUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserMoqParam is the userMoqParam argument value.
			UserMoqParam *user.User
		}
	}
	lockGetOrCreateUser           sync.RWMutex
	lockGetUserAvatar             sync.RWMutex
	lockGetUserByID               sync.RWMutex
	lockInvalidateUserAvatarCache sync.RWMutex
	lockUpdateUser                sync.RWMutex
}

// GetOrCreateUser calls GetOrCreateUserFunc.
func (mock *UserUseCasesMock) GetOrCreateUser(ctx context.Context, slackID string, slackName string, email string, teamID string) (*user.User, error) {
	if mock.GetOrCreateUserFunc == nil {
		panic("UserUseCasesMock.GetOrCreateUserFunc: method is nil but UserUseCases.GetOrCreateUser was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		SlackID   string
		SlackName string
		Email     string
		TeamID    string
	}{
		Ctx:       ctx,
		SlackID:   slackID,
		SlackName: slackName,
		Email:     email,
		TeamID:    teamID,
	}
	mock.lockGetOrCreateUser.Lock()
	mock.calls.GetOrCreateUser = append(mock.calls.GetOrCreateUser, callInfo)
	mock.lockGetOrCreateUser.Unlock()
	return mock.GetOrCreateUserFunc(ctx, slackID, slackName, email, teamID)
}

// GetOrCreateUserCalls gets all the calls that were made to GetOrCreateUser.
// Check the length with:
//
//	len(mockedUserUseCases.GetOrCreateUserCalls())
func (mock *UserUseCasesMock) GetOrCreateUserCalls() []struct {
	Ctx       context.Context
	SlackID   string
	SlackName string
	Email     string
	TeamID    string
} {
	var calls []struct {
		Ctx       context.Context
		SlackID   string
		SlackName string
		Email     string
		TeamID    string
	}
	mock.lockGetOrCreateUser.RLock()
	calls = mock.calls.GetOrCreateUser
	mock.lockGetOrCreateUser.RUnlock()
	return calls
}

// GetUserAvatar calls GetUserAvatarFunc.
func (mock *UserUseCasesMock) GetUserAvatar(ctx context.Context, userID types.UserID, size int) ([]byte, error) {
	if mock.GetUserAvatarFunc == nil {
		panic("UserUseCasesMock.GetUserAvatarFunc: method is nil but UserUseCases.GetUserAvatar was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID types.UserID
		Size   int
	}{
		Ctx:    ctx,
		UserID: userID,
		Size:   size,
	}
	mock.lockGetUserAvatar.Lock()
	mock.calls.GetUserAvatar = append(mock.calls.GetUserAvatar, callInfo)
	mock.lockGetUserAvatar.Unlock()
	return mock.GetUserAvatarFunc(ctx, userID, size)
}

// GetUserAvatarCalls gets all the calls that were made to GetUserAvatar.
// Check the length with:
//
//	len(mockedUserUseCases.GetUserAvatarCalls())
func (mock *UserUseCasesMock) GetUserAvatarCalls() []struct {
	Ctx    context.Context
	UserID types.UserID
	Size   int
} {
	var calls []struct {
		Ctx    context.Context
		UserID types.UserID
		Size   int
	}
	mock.lockGetUserAvatar.RLock()
	calls = mock.calls.GetUserAvatar
	mock.lockGetUserAvatar.RUnlock()
	return calls
}

// GetUserByID calls GetUserByIDFunc.
func (mock *UserUseCasesMock) GetUserByID(ctx context.Context, userID types.UserID) (*user.User, error) {
	if mock.GetUserByIDFunc == nil {
		panic("UserUseCasesMock.GetUserByIDFunc: method is nil but UserUseCases.GetUserByID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID types.UserID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockGetUserByID.Lock()
	mock.calls.GetUserByID = append(mock.calls.GetUserByID, callInfo)
	mock.lockGetUserByID.Unlock()
	return mock.GetUserByIDFunc(ctx, userID)
}

// GetUserByIDCalls gets all the calls that were made to GetUserByID.
// Check the length with:
//
//	len(mockedUserUseCases.GetUserByIDCalls())
func (mock *UserUseCasesMock) GetUserByIDCalls() []struct {
	Ctx    context.Context
	UserID types.UserID
} {
	var calls []struct {
		Ctx    context.Context
		UserID types.UserID
	}
	mock.lockGetUserByID.RLock()
	calls = mock.calls.GetUserByID
	mock.lockGetUserByID.RUnlock()
	return calls
}

// InvalidateUserAvatarCache calls InvalidateUserAvatarCacheFunc.
func (mock *UserUseCasesMock) InvalidateUserAvatarCache(ctx context.Context, userID types.UserID) error {
	if mock.InvalidateUserAvatarCacheFunc == nil {
		panic("UserUseCasesMock.InvalidateUserAvatarCacheFunc: method is nil but UserUseCases.InvalidateUserAvatarCache was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID types.UserID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockInvalidateUserAvatarCache.Lock()
	mock.calls.InvalidateUserAvatarCache = append(mock.calls.InvalidateUserAvatarCache, callInfo)
	mock.lockInvalidateUserAvatarCache.Unlock()
	return mock.InvalidateUserAvatarCacheFunc(ctx, userID)
}

// InvalidateUserAvatarCacheCalls gets all the calls that were made to InvalidateUserAvatarCache.
// Check the length with:
//
//	len(mockedUserUseCases.InvalidateUserAvatarCacheCalls())
func (mock *UserUseCasesMock) InvalidateUserAvatarCacheCalls() []struct {
	Ctx    context.Context
	UserID types.UserID
} {
	var calls []struct {
		Ctx    context.Context
		UserID types.UserID
	}
	mock.lockInvalidateUserAvatarCache.RLock()
	calls = mock.calls.InvalidateUserAvatarCache
	mock.lockInvalidateUserAvatarCache.RUnlock()
	return calls
}

// UpdateUser calls UpdateUserFunc.
func (mock *UserUseCasesMock) UpdateUser(ctx context.Context, userMoqParam *user.User) error {
	if mock.UpdateUserFunc == nil {
		panic("UserUseCasesMock.UpdateUserFunc: method is nil but UserUseCases.UpdateUser was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		UserMoqParam *user.User
	}{
		Ctx:          ctx,
		UserMoqParam: userMoqParam,
	}
	mock.lockUpdateUser.Lock()
	mock.calls.UpdateUser = append(mock.calls.UpdateUser, callInfo)
	mock.lockUpdateUser.Unlock()
	return mock.UpdateUserFunc(ctx, userMoqParam)
}

// UpdateUserCalls gets all the calls that were made to UpdateUser.
// Check the length with:
//
//	len(mockedUserUseCases.UpdateUserCalls())
func (mock *UserUseCasesMock) UpdateUserCalls() []struct {
	Ctx          context.Context
	UserMoqParam *user.User
} {
	var calls []struct {
		Ctx          context.Context
		UserMoqParam *user.User
	}
	mock.lockUpdateUser.RLock()
	calls = mock.calls.UpdateUser
	mock.lockUpdateUser.RUnlock()
	return calls
}
