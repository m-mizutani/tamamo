// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/m-mizutani/gollem"
	"sync"
)

// LLMClientMock is a mock implementation of gollem.LLMClient.
//
//	func TestSomethingThatUsesLLMClient(t *testing.T) {
//
//		// make and configure a mocked gollem.LLMClient
//		mockedLLMClient := &LLMClientMock{
//			CountTokensFunc: func(ctx context.Context, history *gollem.History) (int, error) {
//				panic("mock out the CountTokens method")
//			},
//			GenerateEmbeddingFunc: func(ctx context.Context, dimension int, input []string) ([][]float64, error) {
//				panic("mock out the GenerateEmbedding method")
//			},
//			IsCompatibleHistoryFunc: func(ctx context.Context, history *gollem.History) error {
//				panic("mock out the IsCompatibleHistory method")
//			},
//			NewSessionFunc: func(ctx context.Context, options ...gollem.SessionOption) (gollem.Session, error) {
//				panic("mock out the NewSession method")
//			},
//		}
//
//		// use mockedLLMClient in code that requires gollem.LLMClient
//		// and then make assertions.
//
//	}
type LLMClientMock struct {
	// CountTokensFunc mocks the CountTokens method.
	CountTokensFunc func(ctx context.Context, history *gollem.History) (int, error)

	// GenerateEmbeddingFunc mocks the GenerateEmbedding method.
	GenerateEmbeddingFunc func(ctx context.Context, dimension int, input []string) ([][]float64, error)

	// IsCompatibleHistoryFunc mocks the IsCompatibleHistory method.
	IsCompatibleHistoryFunc func(ctx context.Context, history *gollem.History) error

	// NewSessionFunc mocks the NewSession method.
	NewSessionFunc func(ctx context.Context, options ...gollem.SessionOption) (gollem.Session, error)

	// calls tracks calls to the methods.
	calls struct {
		// CountTokens holds details about calls to the CountTokens method.
		CountTokens []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// History is the history argument value.
			History *gollem.History
		}
		// GenerateEmbedding holds details about calls to the GenerateEmbedding method.
		GenerateEmbedding []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dimension is the dimension argument value.
			Dimension int
			// Input is the input argument value.
			Input []string
		}
		// IsCompatibleHistory holds details about calls to the IsCompatibleHistory method.
		IsCompatibleHistory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// History is the history argument value.
			History *gollem.History
		}
		// NewSession holds details about calls to the NewSession method.
		NewSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Options is the options argument value.
			Options []gollem.SessionOption
		}
	}
	lockCountTokens         sync.RWMutex
	lockGenerateEmbedding   sync.RWMutex
	lockIsCompatibleHistory sync.RWMutex
	lockNewSession          sync.RWMutex
}

// CountTokens calls CountTokensFunc.
func (mock *LLMClientMock) CountTokens(ctx context.Context, history *gollem.History) (int, error) {
	callInfo := struct {
		Ctx     context.Context
		History *gollem.History
	}{
		Ctx:     ctx,
		History: history,
	}
	mock.lockCountTokens.Lock()
	mock.calls.CountTokens = append(mock.calls.CountTokens, callInfo)
	mock.lockCountTokens.Unlock()
	if mock.CountTokensFunc == nil {
		var (
			nOut   int
			errOut error
		)
		return nOut, errOut
	}
	return mock.CountTokensFunc(ctx, history)
}

// CountTokensCalls gets all the calls that were made to CountTokens.
// Check the length with:
//
//	len(mockedLLMClient.CountTokensCalls())
func (mock *LLMClientMock) CountTokensCalls() []struct {
	Ctx     context.Context
	History *gollem.History
} {
	var calls []struct {
		Ctx     context.Context
		History *gollem.History
	}
	mock.lockCountTokens.RLock()
	calls = mock.calls.CountTokens
	mock.lockCountTokens.RUnlock()
	return calls
}

// GenerateEmbedding calls GenerateEmbeddingFunc.
func (mock *LLMClientMock) GenerateEmbedding(ctx context.Context, dimension int, input []string) ([][]float64, error) {
	callInfo := struct {
		Ctx       context.Context
		Dimension int
		Input     []string
	}{
		Ctx:       ctx,
		Dimension: dimension,
		Input:     input,
	}
	mock.lockGenerateEmbedding.Lock()
	mock.calls.GenerateEmbedding = append(mock.calls.GenerateEmbedding, callInfo)
	mock.lockGenerateEmbedding.Unlock()
	if mock.GenerateEmbeddingFunc == nil {
		var (
			float64ssOut [][]float64
			errOut       error
		)
		return float64ssOut, errOut
	}
	return mock.GenerateEmbeddingFunc(ctx, dimension, input)
}

// GenerateEmbeddingCalls gets all the calls that were made to GenerateEmbedding.
// Check the length with:
//
//	len(mockedLLMClient.GenerateEmbeddingCalls())
func (mock *LLMClientMock) GenerateEmbeddingCalls() []struct {
	Ctx       context.Context
	Dimension int
	Input     []string
} {
	var calls []struct {
		Ctx       context.Context
		Dimension int
		Input     []string
	}
	mock.lockGenerateEmbedding.RLock()
	calls = mock.calls.GenerateEmbedding
	mock.lockGenerateEmbedding.RUnlock()
	return calls
}

// IsCompatibleHistory calls IsCompatibleHistoryFunc.
func (mock *LLMClientMock) IsCompatibleHistory(ctx context.Context, history *gollem.History) error {
	callInfo := struct {
		Ctx     context.Context
		History *gollem.History
	}{
		Ctx:     ctx,
		History: history,
	}
	mock.lockIsCompatibleHistory.Lock()
	mock.calls.IsCompatibleHistory = append(mock.calls.IsCompatibleHistory, callInfo)
	mock.lockIsCompatibleHistory.Unlock()
	if mock.IsCompatibleHistoryFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.IsCompatibleHistoryFunc(ctx, history)
}

// IsCompatibleHistoryCalls gets all the calls that were made to IsCompatibleHistory.
// Check the length with:
//
//	len(mockedLLMClient.IsCompatibleHistoryCalls())
func (mock *LLMClientMock) IsCompatibleHistoryCalls() []struct {
	Ctx     context.Context
	History *gollem.History
} {
	var calls []struct {
		Ctx     context.Context
		History *gollem.History
	}
	mock.lockIsCompatibleHistory.RLock()
	calls = mock.calls.IsCompatibleHistory
	mock.lockIsCompatibleHistory.RUnlock()
	return calls
}

// NewSession calls NewSessionFunc.
func (mock *LLMClientMock) NewSession(ctx context.Context, options ...gollem.SessionOption) (gollem.Session, error) {
	callInfo := struct {
		Ctx     context.Context
		Options []gollem.SessionOption
	}{
		Ctx:     ctx,
		Options: options,
	}
	mock.lockNewSession.Lock()
	mock.calls.NewSession = append(mock.calls.NewSession, callInfo)
	mock.lockNewSession.Unlock()
	if mock.NewSessionFunc == nil {
		var (
			sessionOut gollem.Session
			errOut     error
		)
		return sessionOut, errOut
	}
	return mock.NewSessionFunc(ctx, options...)
}

// NewSessionCalls gets all the calls that were made to NewSession.
// Check the length with:
//
//	len(mockedLLMClient.NewSessionCalls())
func (mock *LLMClientMock) NewSessionCalls() []struct {
	Ctx     context.Context
	Options []gollem.SessionOption
} {
	var calls []struct {
		Ctx     context.Context
		Options []gollem.SessionOption
	}
	mock.lockNewSession.RLock()
	calls = mock.calls.NewSession
	mock.lockNewSession.RUnlock()
	return calls
}

// SessionMock is a mock implementation of gollem.Session.
//
//	func TestSomethingThatUsesSession(t *testing.T) {
//
//		// make and configure a mocked gollem.Session
//		mockedSession := &SessionMock{
//			GenerateContentFunc: func(ctx context.Context, input ...gollem.Input) (*gollem.Response, error) {
//				panic("mock out the GenerateContent method")
//			},
//			GenerateStreamFunc: func(ctx context.Context, input ...gollem.Input) (<-chan *gollem.Response, error) {
//				panic("mock out the GenerateStream method")
//			},
//			HistoryFunc: func() *gollem.History {
//				panic("mock out the History method")
//			},
//		}
//
//		// use mockedSession in code that requires gollem.Session
//		// and then make assertions.
//
//	}
type SessionMock struct {
	// GenerateContentFunc mocks the GenerateContent method.
	GenerateContentFunc func(ctx context.Context, input ...gollem.Input) (*gollem.Response, error)

	// GenerateStreamFunc mocks the GenerateStream method.
	GenerateStreamFunc func(ctx context.Context, input ...gollem.Input) (<-chan *gollem.Response, error)

	// HistoryFunc mocks the History method.
	HistoryFunc func() *gollem.History

	// calls tracks calls to the methods.
	calls struct {
		// GenerateContent holds details about calls to the GenerateContent method.
		GenerateContent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input []gollem.Input
		}
		// GenerateStream holds details about calls to the GenerateStream method.
		GenerateStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input []gollem.Input
		}
		// History holds details about calls to the History method.
		History []struct {
		}
	}
	lockGenerateContent sync.RWMutex
	lockGenerateStream  sync.RWMutex
	lockHistory         sync.RWMutex
}

// GenerateContent calls GenerateContentFunc.
func (mock *SessionMock) GenerateContent(ctx context.Context, input ...gollem.Input) (*gollem.Response, error) {
	callInfo := struct {
		Ctx   context.Context
		Input []gollem.Input
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockGenerateContent.Lock()
	mock.calls.GenerateContent = append(mock.calls.GenerateContent, callInfo)
	mock.lockGenerateContent.Unlock()
	if mock.GenerateContentFunc == nil {
		var (
			responseOut *gollem.Response
			errOut      error
		)
		return responseOut, errOut
	}
	return mock.GenerateContentFunc(ctx, input...)
}

// GenerateContentCalls gets all the calls that were made to GenerateContent.
// Check the length with:
//
//	len(mockedSession.GenerateContentCalls())
func (mock *SessionMock) GenerateContentCalls() []struct {
	Ctx   context.Context
	Input []gollem.Input
} {
	var calls []struct {
		Ctx   context.Context
		Input []gollem.Input
	}
	mock.lockGenerateContent.RLock()
	calls = mock.calls.GenerateContent
	mock.lockGenerateContent.RUnlock()
	return calls
}

// GenerateStream calls GenerateStreamFunc.
func (mock *SessionMock) GenerateStream(ctx context.Context, input ...gollem.Input) (<-chan *gollem.Response, error) {
	callInfo := struct {
		Ctx   context.Context
		Input []gollem.Input
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockGenerateStream.Lock()
	mock.calls.GenerateStream = append(mock.calls.GenerateStream, callInfo)
	mock.lockGenerateStream.Unlock()
	if mock.GenerateStreamFunc == nil {
		var (
			responseChOut <-chan *gollem.Response
			errOut        error
		)
		return responseChOut, errOut
	}
	return mock.GenerateStreamFunc(ctx, input...)
}

// GenerateStreamCalls gets all the calls that were made to GenerateStream.
// Check the length with:
//
//	len(mockedSession.GenerateStreamCalls())
func (mock *SessionMock) GenerateStreamCalls() []struct {
	Ctx   context.Context
	Input []gollem.Input
} {
	var calls []struct {
		Ctx   context.Context
		Input []gollem.Input
	}
	mock.lockGenerateStream.RLock()
	calls = mock.calls.GenerateStream
	mock.lockGenerateStream.RUnlock()
	return calls
}

// History calls HistoryFunc.
func (mock *SessionMock) History() *gollem.History {
	callInfo := struct {
	}{}
	mock.lockHistory.Lock()
	mock.calls.History = append(mock.calls.History, callInfo)
	mock.lockHistory.Unlock()
	if mock.HistoryFunc == nil {
		var (
			historyOut *gollem.History
		)
		return historyOut
	}
	return mock.HistoryFunc()
}

// HistoryCalls gets all the calls that were made to History.
// Check the length with:
//
//	len(mockedSession.HistoryCalls())
func (mock *SessionMock) HistoryCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHistory.RLock()
	calls = mock.calls.History
	mock.lockHistory.RUnlock()
	return calls
}

// ToolMock is a mock implementation of gollem.Tool.
//
//	func TestSomethingThatUsesTool(t *testing.T) {
//
//		// make and configure a mocked gollem.Tool
//		mockedTool := &ToolMock{
//			RunFunc: func(ctx context.Context, args map[string]any) (map[string]any, error) {
//				panic("mock out the Run method")
//			},
//			SpecFunc: func() gollem.ToolSpec {
//				panic("mock out the Spec method")
//			},
//		}
//
//		// use mockedTool in code that requires gollem.Tool
//		// and then make assertions.
//
//	}
type ToolMock struct {
	// RunFunc mocks the Run method.
	RunFunc func(ctx context.Context, args map[string]any) (map[string]any, error)

	// SpecFunc mocks the Spec method.
	SpecFunc func() gollem.ToolSpec

	// calls tracks calls to the methods.
	calls struct {
		// Run holds details about calls to the Run method.
		Run []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args map[string]any
		}
		// Spec holds details about calls to the Spec method.
		Spec []struct {
		}
	}
	lockRun  sync.RWMutex
	lockSpec sync.RWMutex
}

// Run calls RunFunc.
func (mock *ToolMock) Run(ctx context.Context, args map[string]any) (map[string]any, error) {
	callInfo := struct {
		Ctx  context.Context
		Args map[string]any
	}{
		Ctx:  ctx,
		Args: args,
	}
	mock.lockRun.Lock()
	mock.calls.Run = append(mock.calls.Run, callInfo)
	mock.lockRun.Unlock()
	if mock.RunFunc == nil {
		var (
			stringToVOut map[string]any
			errOut       error
		)
		return stringToVOut, errOut
	}
	return mock.RunFunc(ctx, args)
}

// RunCalls gets all the calls that were made to Run.
// Check the length with:
//
//	len(mockedTool.RunCalls())
func (mock *ToolMock) RunCalls() []struct {
	Ctx  context.Context
	Args map[string]any
} {
	var calls []struct {
		Ctx  context.Context
		Args map[string]any
	}
	mock.lockRun.RLock()
	calls = mock.calls.Run
	mock.lockRun.RUnlock()
	return calls
}

// Spec calls SpecFunc.
func (mock *ToolMock) Spec() gollem.ToolSpec {
	callInfo := struct {
	}{}
	mock.lockSpec.Lock()
	mock.calls.Spec = append(mock.calls.Spec, callInfo)
	mock.lockSpec.Unlock()
	if mock.SpecFunc == nil {
		var (
			toolSpecOut gollem.ToolSpec
		)
		return toolSpecOut
	}
	return mock.SpecFunc()
}

// SpecCalls gets all the calls that were made to Spec.
// Check the length with:
//
//	len(mockedTool.SpecCalls())
func (mock *ToolMock) SpecCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSpec.RLock()
	calls = mock.calls.Spec
	mock.lockSpec.RUnlock()
	return calls
}
