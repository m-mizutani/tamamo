// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/m-mizutani/tamamo/pkg/domain/interfaces"
	"github.com/m-mizutani/tamamo/pkg/domain/model/slack"
	"github.com/m-mizutani/tamamo/pkg/domain/types"
	"sync"
)

// Ensure, that SlackClientMock does implement interfaces.SlackClient.
// If this is not the case, regenerate this file with moq.
var _ interfaces.SlackClient = &SlackClientMock{}

// SlackClientMock is a mock implementation of interfaces.SlackClient.
//
//	func TestSomethingThatUsesSlackClient(t *testing.T) {
//
//		// make and configure a mocked interfaces.SlackClient
//		mockedSlackClient := &SlackClientMock{
//			GetBotInfoFunc: func(ctx context.Context, botID string) (*interfaces.SlackBotInfo, error) {
//				panic("mock out the GetBotInfo method")
//			},
//			GetUserInfoFunc: func(ctx context.Context, userID string) (*interfaces.SlackUserInfo, error) {
//				panic("mock out the GetUserInfo method")
//			},
//			GetUserProfileFunc: func(ctx context.Context, userID string) (*interfaces.SlackUserProfile, error) {
//				panic("mock out the GetUserProfile method")
//			},
//			IsBotUserFunc: func(userID string) bool {
//				panic("mock out the IsBotUser method")
//			},
//			PostMessageFunc: func(ctx context.Context, channelID string, threadTS string, text string) error {
//				panic("mock out the PostMessage method")
//			},
//			PostMessageWithOptionsFunc: func(ctx context.Context, channelID string, threadTS string, text string, options *interfaces.SlackMessageOptions) error {
//				panic("mock out the PostMessageWithOptions method")
//			},
//		}
//
//		// use mockedSlackClient in code that requires interfaces.SlackClient
//		// and then make assertions.
//
//	}
type SlackClientMock struct {
	// GetBotInfoFunc mocks the GetBotInfo method.
	GetBotInfoFunc func(ctx context.Context, botID string) (*interfaces.SlackBotInfo, error)

	// GetUserInfoFunc mocks the GetUserInfo method.
	GetUserInfoFunc func(ctx context.Context, userID string) (*interfaces.SlackUserInfo, error)

	// GetUserProfileFunc mocks the GetUserProfile method.
	GetUserProfileFunc func(ctx context.Context, userID string) (*interfaces.SlackUserProfile, error)

	// IsBotUserFunc mocks the IsBotUser method.
	IsBotUserFunc func(userID string) bool

	// PostMessageFunc mocks the PostMessage method.
	PostMessageFunc func(ctx context.Context, channelID string, threadTS string, text string) error

	// PostMessageWithOptionsFunc mocks the PostMessageWithOptions method.
	PostMessageWithOptionsFunc func(ctx context.Context, channelID string, threadTS string, text string, options *interfaces.SlackMessageOptions) error

	// calls tracks calls to the methods.
	calls struct {
		// GetBotInfo holds details about calls to the GetBotInfo method.
		GetBotInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BotID is the botID argument value.
			BotID string
		}
		// GetUserInfo holds details about calls to the GetUserInfo method.
		GetUserInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID string
		}
		// GetUserProfile holds details about calls to the GetUserProfile method.
		GetUserProfile []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID string
		}
		// IsBotUser holds details about calls to the IsBotUser method.
		IsBotUser []struct {
			// UserID is the userID argument value.
			UserID string
		}
		// PostMessage holds details about calls to the PostMessage method.
		PostMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ChannelID is the channelID argument value.
			ChannelID string
			// ThreadTS is the threadTS argument value.
			ThreadTS string
			// Text is the text argument value.
			Text string
		}
		// PostMessageWithOptions holds details about calls to the PostMessageWithOptions method.
		PostMessageWithOptions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ChannelID is the channelID argument value.
			ChannelID string
			// ThreadTS is the threadTS argument value.
			ThreadTS string
			// Text is the text argument value.
			Text string
			// Options is the options argument value.
			Options *interfaces.SlackMessageOptions
		}
	}
	lockGetBotInfo             sync.RWMutex
	lockGetUserInfo            sync.RWMutex
	lockGetUserProfile         sync.RWMutex
	lockIsBotUser              sync.RWMutex
	lockPostMessage            sync.RWMutex
	lockPostMessageWithOptions sync.RWMutex
}

// GetBotInfo calls GetBotInfoFunc.
func (mock *SlackClientMock) GetBotInfo(ctx context.Context, botID string) (*interfaces.SlackBotInfo, error) {
	if mock.GetBotInfoFunc == nil {
		panic("SlackClientMock.GetBotInfoFunc: method is nil but SlackClient.GetBotInfo was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		BotID string
	}{
		Ctx:   ctx,
		BotID: botID,
	}
	mock.lockGetBotInfo.Lock()
	mock.calls.GetBotInfo = append(mock.calls.GetBotInfo, callInfo)
	mock.lockGetBotInfo.Unlock()
	return mock.GetBotInfoFunc(ctx, botID)
}

// GetBotInfoCalls gets all the calls that were made to GetBotInfo.
// Check the length with:
//
//	len(mockedSlackClient.GetBotInfoCalls())
func (mock *SlackClientMock) GetBotInfoCalls() []struct {
	Ctx   context.Context
	BotID string
} {
	var calls []struct {
		Ctx   context.Context
		BotID string
	}
	mock.lockGetBotInfo.RLock()
	calls = mock.calls.GetBotInfo
	mock.lockGetBotInfo.RUnlock()
	return calls
}

// GetUserInfo calls GetUserInfoFunc.
func (mock *SlackClientMock) GetUserInfo(ctx context.Context, userID string) (*interfaces.SlackUserInfo, error) {
	if mock.GetUserInfoFunc == nil {
		panic("SlackClientMock.GetUserInfoFunc: method is nil but SlackClient.GetUserInfo was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID string
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockGetUserInfo.Lock()
	mock.calls.GetUserInfo = append(mock.calls.GetUserInfo, callInfo)
	mock.lockGetUserInfo.Unlock()
	return mock.GetUserInfoFunc(ctx, userID)
}

// GetUserInfoCalls gets all the calls that were made to GetUserInfo.
// Check the length with:
//
//	len(mockedSlackClient.GetUserInfoCalls())
func (mock *SlackClientMock) GetUserInfoCalls() []struct {
	Ctx    context.Context
	UserID string
} {
	var calls []struct {
		Ctx    context.Context
		UserID string
	}
	mock.lockGetUserInfo.RLock()
	calls = mock.calls.GetUserInfo
	mock.lockGetUserInfo.RUnlock()
	return calls
}

// GetUserProfile calls GetUserProfileFunc.
func (mock *SlackClientMock) GetUserProfile(ctx context.Context, userID string) (*interfaces.SlackUserProfile, error) {
	if mock.GetUserProfileFunc == nil {
		panic("SlackClientMock.GetUserProfileFunc: method is nil but SlackClient.GetUserProfile was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID string
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockGetUserProfile.Lock()
	mock.calls.GetUserProfile = append(mock.calls.GetUserProfile, callInfo)
	mock.lockGetUserProfile.Unlock()
	return mock.GetUserProfileFunc(ctx, userID)
}

// GetUserProfileCalls gets all the calls that were made to GetUserProfile.
// Check the length with:
//
//	len(mockedSlackClient.GetUserProfileCalls())
func (mock *SlackClientMock) GetUserProfileCalls() []struct {
	Ctx    context.Context
	UserID string
} {
	var calls []struct {
		Ctx    context.Context
		UserID string
	}
	mock.lockGetUserProfile.RLock()
	calls = mock.calls.GetUserProfile
	mock.lockGetUserProfile.RUnlock()
	return calls
}

// IsBotUser calls IsBotUserFunc.
func (mock *SlackClientMock) IsBotUser(userID string) bool {
	if mock.IsBotUserFunc == nil {
		panic("SlackClientMock.IsBotUserFunc: method is nil but SlackClient.IsBotUser was just called")
	}
	callInfo := struct {
		UserID string
	}{
		UserID: userID,
	}
	mock.lockIsBotUser.Lock()
	mock.calls.IsBotUser = append(mock.calls.IsBotUser, callInfo)
	mock.lockIsBotUser.Unlock()
	return mock.IsBotUserFunc(userID)
}

// IsBotUserCalls gets all the calls that were made to IsBotUser.
// Check the length with:
//
//	len(mockedSlackClient.IsBotUserCalls())
func (mock *SlackClientMock) IsBotUserCalls() []struct {
	UserID string
} {
	var calls []struct {
		UserID string
	}
	mock.lockIsBotUser.RLock()
	calls = mock.calls.IsBotUser
	mock.lockIsBotUser.RUnlock()
	return calls
}

// PostMessage calls PostMessageFunc.
func (mock *SlackClientMock) PostMessage(ctx context.Context, channelID string, threadTS string, text string) error {
	if mock.PostMessageFunc == nil {
		panic("SlackClientMock.PostMessageFunc: method is nil but SlackClient.PostMessage was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ChannelID string
		ThreadTS  string
		Text      string
	}{
		Ctx:       ctx,
		ChannelID: channelID,
		ThreadTS:  threadTS,
		Text:      text,
	}
	mock.lockPostMessage.Lock()
	mock.calls.PostMessage = append(mock.calls.PostMessage, callInfo)
	mock.lockPostMessage.Unlock()
	return mock.PostMessageFunc(ctx, channelID, threadTS, text)
}

// PostMessageCalls gets all the calls that were made to PostMessage.
// Check the length with:
//
//	len(mockedSlackClient.PostMessageCalls())
func (mock *SlackClientMock) PostMessageCalls() []struct {
	Ctx       context.Context
	ChannelID string
	ThreadTS  string
	Text      string
} {
	var calls []struct {
		Ctx       context.Context
		ChannelID string
		ThreadTS  string
		Text      string
	}
	mock.lockPostMessage.RLock()
	calls = mock.calls.PostMessage
	mock.lockPostMessage.RUnlock()
	return calls
}

// PostMessageWithOptions calls PostMessageWithOptionsFunc.
func (mock *SlackClientMock) PostMessageWithOptions(ctx context.Context, channelID string, threadTS string, text string, options *interfaces.SlackMessageOptions) error {
	if mock.PostMessageWithOptionsFunc == nil {
		panic("SlackClientMock.PostMessageWithOptionsFunc: method is nil but SlackClient.PostMessageWithOptions was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ChannelID string
		ThreadTS  string
		Text      string
		Options   *interfaces.SlackMessageOptions
	}{
		Ctx:       ctx,
		ChannelID: channelID,
		ThreadTS:  threadTS,
		Text:      text,
		Options:   options,
	}
	mock.lockPostMessageWithOptions.Lock()
	mock.calls.PostMessageWithOptions = append(mock.calls.PostMessageWithOptions, callInfo)
	mock.lockPostMessageWithOptions.Unlock()
	return mock.PostMessageWithOptionsFunc(ctx, channelID, threadTS, text, options)
}

// PostMessageWithOptionsCalls gets all the calls that were made to PostMessageWithOptions.
// Check the length with:
//
//	len(mockedSlackClient.PostMessageWithOptionsCalls())
func (mock *SlackClientMock) PostMessageWithOptionsCalls() []struct {
	Ctx       context.Context
	ChannelID string
	ThreadTS  string
	Text      string
	Options   *interfaces.SlackMessageOptions
} {
	var calls []struct {
		Ctx       context.Context
		ChannelID string
		ThreadTS  string
		Text      string
		Options   *interfaces.SlackMessageOptions
	}
	mock.lockPostMessageWithOptions.RLock()
	calls = mock.calls.PostMessageWithOptions
	mock.lockPostMessageWithOptions.RUnlock()
	return calls
}

// Ensure, that ThreadRepositoryMock does implement interfaces.ThreadRepository.
// If this is not the case, regenerate this file with moq.
var _ interfaces.ThreadRepository = &ThreadRepositoryMock{}

// ThreadRepositoryMock is a mock implementation of interfaces.ThreadRepository.
//
//	func TestSomethingThatUsesThreadRepository(t *testing.T) {
//
//		// make and configure a mocked interfaces.ThreadRepository
//		mockedThreadRepository := &ThreadRepositoryMock{
//			GetHistoryByIDFunc: func(ctx context.Context, id types.HistoryID) (*slack.History, error) {
//				panic("mock out the GetHistoryByID method")
//			},
//			GetLatestHistoryFunc: func(ctx context.Context, threadID types.ThreadID) (*slack.History, error) {
//				panic("mock out the GetLatestHistory method")
//			},
//			GetOrPutThreadFunc: func(ctx context.Context, teamID string, channelID string, threadTS string) (*slack.Thread, error) {
//				panic("mock out the GetOrPutThread method")
//			},
//			GetOrPutThreadWithAgentFunc: func(ctx context.Context, teamID string, channelID string, threadTS string, agentUUID *types.UUID, agentVersion string) (*slack.Thread, error) {
//				panic("mock out the GetOrPutThreadWithAgent method")
//			},
//			GetThreadFunc: func(ctx context.Context, id types.ThreadID) (*slack.Thread, error) {
//				panic("mock out the GetThread method")
//			},
//			GetThreadByTSFunc: func(ctx context.Context, channelID string, threadTS string) (*slack.Thread, error) {
//				panic("mock out the GetThreadByTS method")
//			},
//			GetThreadMessagesFunc: func(ctx context.Context, threadID types.ThreadID) ([]*slack.Message, error) {
//				panic("mock out the GetThreadMessages method")
//			},
//			ListThreadsFunc: func(ctx context.Context, offset int, limit int) ([]*slack.Thread, int, error) {
//				panic("mock out the ListThreads method")
//			},
//			PutHistoryFunc: func(ctx context.Context, history *slack.History) error {
//				panic("mock out the PutHistory method")
//			},
//			PutThreadMessageFunc: func(ctx context.Context, threadID types.ThreadID, message *slack.Message) error {
//				panic("mock out the PutThreadMessage method")
//			},
//		}
//
//		// use mockedThreadRepository in code that requires interfaces.ThreadRepository
//		// and then make assertions.
//
//	}
type ThreadRepositoryMock struct {
	// GetHistoryByIDFunc mocks the GetHistoryByID method.
	GetHistoryByIDFunc func(ctx context.Context, id types.HistoryID) (*slack.History, error)

	// GetLatestHistoryFunc mocks the GetLatestHistory method.
	GetLatestHistoryFunc func(ctx context.Context, threadID types.ThreadID) (*slack.History, error)

	// GetOrPutThreadFunc mocks the GetOrPutThread method.
	GetOrPutThreadFunc func(ctx context.Context, teamID string, channelID string, threadTS string) (*slack.Thread, error)

	// GetOrPutThreadWithAgentFunc mocks the GetOrPutThreadWithAgent method.
	GetOrPutThreadWithAgentFunc func(ctx context.Context, teamID string, channelID string, threadTS string, agentUUID *types.UUID, agentVersion string) (*slack.Thread, error)

	// GetThreadFunc mocks the GetThread method.
	GetThreadFunc func(ctx context.Context, id types.ThreadID) (*slack.Thread, error)

	// GetThreadByTSFunc mocks the GetThreadByTS method.
	GetThreadByTSFunc func(ctx context.Context, channelID string, threadTS string) (*slack.Thread, error)

	// GetThreadMessagesFunc mocks the GetThreadMessages method.
	GetThreadMessagesFunc func(ctx context.Context, threadID types.ThreadID) ([]*slack.Message, error)

	// ListThreadsFunc mocks the ListThreads method.
	ListThreadsFunc func(ctx context.Context, offset int, limit int) ([]*slack.Thread, int, error)

	// PutHistoryFunc mocks the PutHistory method.
	PutHistoryFunc func(ctx context.Context, history *slack.History) error

	// PutThreadMessageFunc mocks the PutThreadMessage method.
	PutThreadMessageFunc func(ctx context.Context, threadID types.ThreadID, message *slack.Message) error

	// calls tracks calls to the methods.
	calls struct {
		// GetHistoryByID holds details about calls to the GetHistoryByID method.
		GetHistoryByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID types.HistoryID
		}
		// GetLatestHistory holds details about calls to the GetLatestHistory method.
		GetLatestHistory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ThreadID is the threadID argument value.
			ThreadID types.ThreadID
		}
		// GetOrPutThread holds details about calls to the GetOrPutThread method.
		GetOrPutThread []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TeamID is the teamID argument value.
			TeamID string
			// ChannelID is the channelID argument value.
			ChannelID string
			// ThreadTS is the threadTS argument value.
			ThreadTS string
		}
		// GetOrPutThreadWithAgent holds details about calls to the GetOrPutThreadWithAgent method.
		GetOrPutThreadWithAgent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TeamID is the teamID argument value.
			TeamID string
			// ChannelID is the channelID argument value.
			ChannelID string
			// ThreadTS is the threadTS argument value.
			ThreadTS string
			// AgentUUID is the agentUUID argument value.
			AgentUUID *types.UUID
			// AgentVersion is the agentVersion argument value.
			AgentVersion string
		}
		// GetThread holds details about calls to the GetThread method.
		GetThread []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID types.ThreadID
		}
		// GetThreadByTS holds details about calls to the GetThreadByTS method.
		GetThreadByTS []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ChannelID is the channelID argument value.
			ChannelID string
			// ThreadTS is the threadTS argument value.
			ThreadTS string
		}
		// GetThreadMessages holds details about calls to the GetThreadMessages method.
		GetThreadMessages []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ThreadID is the threadID argument value.
			ThreadID types.ThreadID
		}
		// ListThreads holds details about calls to the ListThreads method.
		ListThreads []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// PutHistory holds details about calls to the PutHistory method.
		PutHistory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// History is the history argument value.
			History *slack.History
		}
		// PutThreadMessage holds details about calls to the PutThreadMessage method.
		PutThreadMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ThreadID is the threadID argument value.
			ThreadID types.ThreadID
			// Message is the message argument value.
			Message *slack.Message
		}
	}
	lockGetHistoryByID          sync.RWMutex
	lockGetLatestHistory        sync.RWMutex
	lockGetOrPutThread          sync.RWMutex
	lockGetOrPutThreadWithAgent sync.RWMutex
	lockGetThread               sync.RWMutex
	lockGetThreadByTS           sync.RWMutex
	lockGetThreadMessages       sync.RWMutex
	lockListThreads             sync.RWMutex
	lockPutHistory              sync.RWMutex
	lockPutThreadMessage        sync.RWMutex
}

// GetHistoryByID calls GetHistoryByIDFunc.
func (mock *ThreadRepositoryMock) GetHistoryByID(ctx context.Context, id types.HistoryID) (*slack.History, error) {
	if mock.GetHistoryByIDFunc == nil {
		panic("ThreadRepositoryMock.GetHistoryByIDFunc: method is nil but ThreadRepository.GetHistoryByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  types.HistoryID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetHistoryByID.Lock()
	mock.calls.GetHistoryByID = append(mock.calls.GetHistoryByID, callInfo)
	mock.lockGetHistoryByID.Unlock()
	return mock.GetHistoryByIDFunc(ctx, id)
}

// GetHistoryByIDCalls gets all the calls that were made to GetHistoryByID.
// Check the length with:
//
//	len(mockedThreadRepository.GetHistoryByIDCalls())
func (mock *ThreadRepositoryMock) GetHistoryByIDCalls() []struct {
	Ctx context.Context
	ID  types.HistoryID
} {
	var calls []struct {
		Ctx context.Context
		ID  types.HistoryID
	}
	mock.lockGetHistoryByID.RLock()
	calls = mock.calls.GetHistoryByID
	mock.lockGetHistoryByID.RUnlock()
	return calls
}

// GetLatestHistory calls GetLatestHistoryFunc.
func (mock *ThreadRepositoryMock) GetLatestHistory(ctx context.Context, threadID types.ThreadID) (*slack.History, error) {
	if mock.GetLatestHistoryFunc == nil {
		panic("ThreadRepositoryMock.GetLatestHistoryFunc: method is nil but ThreadRepository.GetLatestHistory was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		ThreadID types.ThreadID
	}{
		Ctx:      ctx,
		ThreadID: threadID,
	}
	mock.lockGetLatestHistory.Lock()
	mock.calls.GetLatestHistory = append(mock.calls.GetLatestHistory, callInfo)
	mock.lockGetLatestHistory.Unlock()
	return mock.GetLatestHistoryFunc(ctx, threadID)
}

// GetLatestHistoryCalls gets all the calls that were made to GetLatestHistory.
// Check the length with:
//
//	len(mockedThreadRepository.GetLatestHistoryCalls())
func (mock *ThreadRepositoryMock) GetLatestHistoryCalls() []struct {
	Ctx      context.Context
	ThreadID types.ThreadID
} {
	var calls []struct {
		Ctx      context.Context
		ThreadID types.ThreadID
	}
	mock.lockGetLatestHistory.RLock()
	calls = mock.calls.GetLatestHistory
	mock.lockGetLatestHistory.RUnlock()
	return calls
}

// GetOrPutThread calls GetOrPutThreadFunc.
func (mock *ThreadRepositoryMock) GetOrPutThread(ctx context.Context, teamID string, channelID string, threadTS string) (*slack.Thread, error) {
	if mock.GetOrPutThreadFunc == nil {
		panic("ThreadRepositoryMock.GetOrPutThreadFunc: method is nil but ThreadRepository.GetOrPutThread was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		TeamID    string
		ChannelID string
		ThreadTS  string
	}{
		Ctx:       ctx,
		TeamID:    teamID,
		ChannelID: channelID,
		ThreadTS:  threadTS,
	}
	mock.lockGetOrPutThread.Lock()
	mock.calls.GetOrPutThread = append(mock.calls.GetOrPutThread, callInfo)
	mock.lockGetOrPutThread.Unlock()
	return mock.GetOrPutThreadFunc(ctx, teamID, channelID, threadTS)
}

// GetOrPutThreadCalls gets all the calls that were made to GetOrPutThread.
// Check the length with:
//
//	len(mockedThreadRepository.GetOrPutThreadCalls())
func (mock *ThreadRepositoryMock) GetOrPutThreadCalls() []struct {
	Ctx       context.Context
	TeamID    string
	ChannelID string
	ThreadTS  string
} {
	var calls []struct {
		Ctx       context.Context
		TeamID    string
		ChannelID string
		ThreadTS  string
	}
	mock.lockGetOrPutThread.RLock()
	calls = mock.calls.GetOrPutThread
	mock.lockGetOrPutThread.RUnlock()
	return calls
}

// GetOrPutThreadWithAgent calls GetOrPutThreadWithAgentFunc.
func (mock *ThreadRepositoryMock) GetOrPutThreadWithAgent(ctx context.Context, teamID string, channelID string, threadTS string, agentUUID *types.UUID, agentVersion string) (*slack.Thread, error) {
	if mock.GetOrPutThreadWithAgentFunc == nil {
		panic("ThreadRepositoryMock.GetOrPutThreadWithAgentFunc: method is nil but ThreadRepository.GetOrPutThreadWithAgent was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		TeamID       string
		ChannelID    string
		ThreadTS     string
		AgentUUID    *types.UUID
		AgentVersion string
	}{
		Ctx:          ctx,
		TeamID:       teamID,
		ChannelID:    channelID,
		ThreadTS:     threadTS,
		AgentUUID:    agentUUID,
		AgentVersion: agentVersion,
	}
	mock.lockGetOrPutThreadWithAgent.Lock()
	mock.calls.GetOrPutThreadWithAgent = append(mock.calls.GetOrPutThreadWithAgent, callInfo)
	mock.lockGetOrPutThreadWithAgent.Unlock()
	return mock.GetOrPutThreadWithAgentFunc(ctx, teamID, channelID, threadTS, agentUUID, agentVersion)
}

// GetOrPutThreadWithAgentCalls gets all the calls that were made to GetOrPutThreadWithAgent.
// Check the length with:
//
//	len(mockedThreadRepository.GetOrPutThreadWithAgentCalls())
func (mock *ThreadRepositoryMock) GetOrPutThreadWithAgentCalls() []struct {
	Ctx          context.Context
	TeamID       string
	ChannelID    string
	ThreadTS     string
	AgentUUID    *types.UUID
	AgentVersion string
} {
	var calls []struct {
		Ctx          context.Context
		TeamID       string
		ChannelID    string
		ThreadTS     string
		AgentUUID    *types.UUID
		AgentVersion string
	}
	mock.lockGetOrPutThreadWithAgent.RLock()
	calls = mock.calls.GetOrPutThreadWithAgent
	mock.lockGetOrPutThreadWithAgent.RUnlock()
	return calls
}

// GetThread calls GetThreadFunc.
func (mock *ThreadRepositoryMock) GetThread(ctx context.Context, id types.ThreadID) (*slack.Thread, error) {
	if mock.GetThreadFunc == nil {
		panic("ThreadRepositoryMock.GetThreadFunc: method is nil but ThreadRepository.GetThread was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  types.ThreadID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetThread.Lock()
	mock.calls.GetThread = append(mock.calls.GetThread, callInfo)
	mock.lockGetThread.Unlock()
	return mock.GetThreadFunc(ctx, id)
}

// GetThreadCalls gets all the calls that were made to GetThread.
// Check the length with:
//
//	len(mockedThreadRepository.GetThreadCalls())
func (mock *ThreadRepositoryMock) GetThreadCalls() []struct {
	Ctx context.Context
	ID  types.ThreadID
} {
	var calls []struct {
		Ctx context.Context
		ID  types.ThreadID
	}
	mock.lockGetThread.RLock()
	calls = mock.calls.GetThread
	mock.lockGetThread.RUnlock()
	return calls
}

// GetThreadByTS calls GetThreadByTSFunc.
func (mock *ThreadRepositoryMock) GetThreadByTS(ctx context.Context, channelID string, threadTS string) (*slack.Thread, error) {
	if mock.GetThreadByTSFunc == nil {
		panic("ThreadRepositoryMock.GetThreadByTSFunc: method is nil but ThreadRepository.GetThreadByTS was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ChannelID string
		ThreadTS  string
	}{
		Ctx:       ctx,
		ChannelID: channelID,
		ThreadTS:  threadTS,
	}
	mock.lockGetThreadByTS.Lock()
	mock.calls.GetThreadByTS = append(mock.calls.GetThreadByTS, callInfo)
	mock.lockGetThreadByTS.Unlock()
	return mock.GetThreadByTSFunc(ctx, channelID, threadTS)
}

// GetThreadByTSCalls gets all the calls that were made to GetThreadByTS.
// Check the length with:
//
//	len(mockedThreadRepository.GetThreadByTSCalls())
func (mock *ThreadRepositoryMock) GetThreadByTSCalls() []struct {
	Ctx       context.Context
	ChannelID string
	ThreadTS  string
} {
	var calls []struct {
		Ctx       context.Context
		ChannelID string
		ThreadTS  string
	}
	mock.lockGetThreadByTS.RLock()
	calls = mock.calls.GetThreadByTS
	mock.lockGetThreadByTS.RUnlock()
	return calls
}

// GetThreadMessages calls GetThreadMessagesFunc.
func (mock *ThreadRepositoryMock) GetThreadMessages(ctx context.Context, threadID types.ThreadID) ([]*slack.Message, error) {
	if mock.GetThreadMessagesFunc == nil {
		panic("ThreadRepositoryMock.GetThreadMessagesFunc: method is nil but ThreadRepository.GetThreadMessages was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		ThreadID types.ThreadID
	}{
		Ctx:      ctx,
		ThreadID: threadID,
	}
	mock.lockGetThreadMessages.Lock()
	mock.calls.GetThreadMessages = append(mock.calls.GetThreadMessages, callInfo)
	mock.lockGetThreadMessages.Unlock()
	return mock.GetThreadMessagesFunc(ctx, threadID)
}

// GetThreadMessagesCalls gets all the calls that were made to GetThreadMessages.
// Check the length with:
//
//	len(mockedThreadRepository.GetThreadMessagesCalls())
func (mock *ThreadRepositoryMock) GetThreadMessagesCalls() []struct {
	Ctx      context.Context
	ThreadID types.ThreadID
} {
	var calls []struct {
		Ctx      context.Context
		ThreadID types.ThreadID
	}
	mock.lockGetThreadMessages.RLock()
	calls = mock.calls.GetThreadMessages
	mock.lockGetThreadMessages.RUnlock()
	return calls
}

// ListThreads calls ListThreadsFunc.
func (mock *ThreadRepositoryMock) ListThreads(ctx context.Context, offset int, limit int) ([]*slack.Thread, int, error) {
	if mock.ListThreadsFunc == nil {
		panic("ThreadRepositoryMock.ListThreadsFunc: method is nil but ThreadRepository.ListThreads was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Offset int
		Limit  int
	}{
		Ctx:    ctx,
		Offset: offset,
		Limit:  limit,
	}
	mock.lockListThreads.Lock()
	mock.calls.ListThreads = append(mock.calls.ListThreads, callInfo)
	mock.lockListThreads.Unlock()
	return mock.ListThreadsFunc(ctx, offset, limit)
}

// ListThreadsCalls gets all the calls that were made to ListThreads.
// Check the length with:
//
//	len(mockedThreadRepository.ListThreadsCalls())
func (mock *ThreadRepositoryMock) ListThreadsCalls() []struct {
	Ctx    context.Context
	Offset int
	Limit  int
} {
	var calls []struct {
		Ctx    context.Context
		Offset int
		Limit  int
	}
	mock.lockListThreads.RLock()
	calls = mock.calls.ListThreads
	mock.lockListThreads.RUnlock()
	return calls
}

// PutHistory calls PutHistoryFunc.
func (mock *ThreadRepositoryMock) PutHistory(ctx context.Context, history *slack.History) error {
	if mock.PutHistoryFunc == nil {
		panic("ThreadRepositoryMock.PutHistoryFunc: method is nil but ThreadRepository.PutHistory was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		History *slack.History
	}{
		Ctx:     ctx,
		History: history,
	}
	mock.lockPutHistory.Lock()
	mock.calls.PutHistory = append(mock.calls.PutHistory, callInfo)
	mock.lockPutHistory.Unlock()
	return mock.PutHistoryFunc(ctx, history)
}

// PutHistoryCalls gets all the calls that were made to PutHistory.
// Check the length with:
//
//	len(mockedThreadRepository.PutHistoryCalls())
func (mock *ThreadRepositoryMock) PutHistoryCalls() []struct {
	Ctx     context.Context
	History *slack.History
} {
	var calls []struct {
		Ctx     context.Context
		History *slack.History
	}
	mock.lockPutHistory.RLock()
	calls = mock.calls.PutHistory
	mock.lockPutHistory.RUnlock()
	return calls
}

// PutThreadMessage calls PutThreadMessageFunc.
func (mock *ThreadRepositoryMock) PutThreadMessage(ctx context.Context, threadID types.ThreadID, message *slack.Message) error {
	if mock.PutThreadMessageFunc == nil {
		panic("ThreadRepositoryMock.PutThreadMessageFunc: method is nil but ThreadRepository.PutThreadMessage was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		ThreadID types.ThreadID
		Message  *slack.Message
	}{
		Ctx:      ctx,
		ThreadID: threadID,
		Message:  message,
	}
	mock.lockPutThreadMessage.Lock()
	mock.calls.PutThreadMessage = append(mock.calls.PutThreadMessage, callInfo)
	mock.lockPutThreadMessage.Unlock()
	return mock.PutThreadMessageFunc(ctx, threadID, message)
}

// PutThreadMessageCalls gets all the calls that were made to PutThreadMessage.
// Check the length with:
//
//	len(mockedThreadRepository.PutThreadMessageCalls())
func (mock *ThreadRepositoryMock) PutThreadMessageCalls() []struct {
	Ctx      context.Context
	ThreadID types.ThreadID
	Message  *slack.Message
} {
	var calls []struct {
		Ctx      context.Context
		ThreadID types.ThreadID
		Message  *slack.Message
	}
	mock.lockPutThreadMessage.RLock()
	calls = mock.calls.PutThreadMessage
	mock.lockPutThreadMessage.RUnlock()
	return calls
}

// Ensure, that HistoryRepositoryMock does implement interfaces.HistoryRepository.
// If this is not the case, regenerate this file with moq.
var _ interfaces.HistoryRepository = &HistoryRepositoryMock{}

// HistoryRepositoryMock is a mock implementation of interfaces.HistoryRepository.
//
//	func TestSomethingThatUsesHistoryRepository(t *testing.T) {
//
//		// make and configure a mocked interfaces.HistoryRepository
//		mockedHistoryRepository := &HistoryRepositoryMock{
//			GetHistoryByIDFunc: func(ctx context.Context, id types.HistoryID) (*slack.History, error) {
//				panic("mock out the GetHistoryByID method")
//			},
//			GetLatestHistoryFunc: func(ctx context.Context, threadID types.ThreadID) (*slack.History, error) {
//				panic("mock out the GetLatestHistory method")
//			},
//			PutHistoryFunc: func(ctx context.Context, history *slack.History) error {
//				panic("mock out the PutHistory method")
//			},
//		}
//
//		// use mockedHistoryRepository in code that requires interfaces.HistoryRepository
//		// and then make assertions.
//
//	}
type HistoryRepositoryMock struct {
	// GetHistoryByIDFunc mocks the GetHistoryByID method.
	GetHistoryByIDFunc func(ctx context.Context, id types.HistoryID) (*slack.History, error)

	// GetLatestHistoryFunc mocks the GetLatestHistory method.
	GetLatestHistoryFunc func(ctx context.Context, threadID types.ThreadID) (*slack.History, error)

	// PutHistoryFunc mocks the PutHistory method.
	PutHistoryFunc func(ctx context.Context, history *slack.History) error

	// calls tracks calls to the methods.
	calls struct {
		// GetHistoryByID holds details about calls to the GetHistoryByID method.
		GetHistoryByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID types.HistoryID
		}
		// GetLatestHistory holds details about calls to the GetLatestHistory method.
		GetLatestHistory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ThreadID is the threadID argument value.
			ThreadID types.ThreadID
		}
		// PutHistory holds details about calls to the PutHistory method.
		PutHistory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// History is the history argument value.
			History *slack.History
		}
	}
	lockGetHistoryByID   sync.RWMutex
	lockGetLatestHistory sync.RWMutex
	lockPutHistory       sync.RWMutex
}

// GetHistoryByID calls GetHistoryByIDFunc.
func (mock *HistoryRepositoryMock) GetHistoryByID(ctx context.Context, id types.HistoryID) (*slack.History, error) {
	if mock.GetHistoryByIDFunc == nil {
		panic("HistoryRepositoryMock.GetHistoryByIDFunc: method is nil but HistoryRepository.GetHistoryByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  types.HistoryID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetHistoryByID.Lock()
	mock.calls.GetHistoryByID = append(mock.calls.GetHistoryByID, callInfo)
	mock.lockGetHistoryByID.Unlock()
	return mock.GetHistoryByIDFunc(ctx, id)
}

// GetHistoryByIDCalls gets all the calls that were made to GetHistoryByID.
// Check the length with:
//
//	len(mockedHistoryRepository.GetHistoryByIDCalls())
func (mock *HistoryRepositoryMock) GetHistoryByIDCalls() []struct {
	Ctx context.Context
	ID  types.HistoryID
} {
	var calls []struct {
		Ctx context.Context
		ID  types.HistoryID
	}
	mock.lockGetHistoryByID.RLock()
	calls = mock.calls.GetHistoryByID
	mock.lockGetHistoryByID.RUnlock()
	return calls
}

// GetLatestHistory calls GetLatestHistoryFunc.
func (mock *HistoryRepositoryMock) GetLatestHistory(ctx context.Context, threadID types.ThreadID) (*slack.History, error) {
	if mock.GetLatestHistoryFunc == nil {
		panic("HistoryRepositoryMock.GetLatestHistoryFunc: method is nil but HistoryRepository.GetLatestHistory was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		ThreadID types.ThreadID
	}{
		Ctx:      ctx,
		ThreadID: threadID,
	}
	mock.lockGetLatestHistory.Lock()
	mock.calls.GetLatestHistory = append(mock.calls.GetLatestHistory, callInfo)
	mock.lockGetLatestHistory.Unlock()
	return mock.GetLatestHistoryFunc(ctx, threadID)
}

// GetLatestHistoryCalls gets all the calls that were made to GetLatestHistory.
// Check the length with:
//
//	len(mockedHistoryRepository.GetLatestHistoryCalls())
func (mock *HistoryRepositoryMock) GetLatestHistoryCalls() []struct {
	Ctx      context.Context
	ThreadID types.ThreadID
} {
	var calls []struct {
		Ctx      context.Context
		ThreadID types.ThreadID
	}
	mock.lockGetLatestHistory.RLock()
	calls = mock.calls.GetLatestHistory
	mock.lockGetLatestHistory.RUnlock()
	return calls
}

// PutHistory calls PutHistoryFunc.
func (mock *HistoryRepositoryMock) PutHistory(ctx context.Context, history *slack.History) error {
	if mock.PutHistoryFunc == nil {
		panic("HistoryRepositoryMock.PutHistoryFunc: method is nil but HistoryRepository.PutHistory was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		History *slack.History
	}{
		Ctx:     ctx,
		History: history,
	}
	mock.lockPutHistory.Lock()
	mock.calls.PutHistory = append(mock.calls.PutHistory, callInfo)
	mock.lockPutHistory.Unlock()
	return mock.PutHistoryFunc(ctx, history)
}

// PutHistoryCalls gets all the calls that were made to PutHistory.
// Check the length with:
//
//	len(mockedHistoryRepository.PutHistoryCalls())
func (mock *HistoryRepositoryMock) PutHistoryCalls() []struct {
	Ctx     context.Context
	History *slack.History
} {
	var calls []struct {
		Ctx     context.Context
		History *slack.History
	}
	mock.lockPutHistory.RLock()
	calls = mock.calls.PutHistory
	mock.lockPutHistory.RUnlock()
	return calls
}

// Ensure, that StorageAdapterMock does implement interfaces.StorageAdapter.
// If this is not the case, regenerate this file with moq.
var _ interfaces.StorageAdapter = &StorageAdapterMock{}

// StorageAdapterMock is a mock implementation of interfaces.StorageAdapter.
//
//	func TestSomethingThatUsesStorageAdapter(t *testing.T) {
//
//		// make and configure a mocked interfaces.StorageAdapter
//		mockedStorageAdapter := &StorageAdapterMock{
//			GetFunc: func(ctx context.Context, key string) ([]byte, error) {
//				panic("mock out the Get method")
//			},
//			PutFunc: func(ctx context.Context, key string, data []byte) error {
//				panic("mock out the Put method")
//			},
//		}
//
//		// use mockedStorageAdapter in code that requires interfaces.StorageAdapter
//		// and then make assertions.
//
//	}
type StorageAdapterMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, key string) ([]byte, error)

	// PutFunc mocks the Put method.
	PutFunc func(ctx context.Context, key string, data []byte) error

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Put holds details about calls to the Put method.
		Put []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Data is the data argument value.
			Data []byte
		}
	}
	lockGet sync.RWMutex
	lockPut sync.RWMutex
}

// Get calls GetFunc.
func (mock *StorageAdapterMock) Get(ctx context.Context, key string) ([]byte, error) {
	if mock.GetFunc == nil {
		panic("StorageAdapterMock.GetFunc: method is nil but StorageAdapter.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, key)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedStorageAdapter.GetCalls())
func (mock *StorageAdapterMock) GetCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// Put calls PutFunc.
func (mock *StorageAdapterMock) Put(ctx context.Context, key string, data []byte) error {
	if mock.PutFunc == nil {
		panic("StorageAdapterMock.PutFunc: method is nil but StorageAdapter.Put was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Data []byte
	}{
		Ctx:  ctx,
		Key:  key,
		Data: data,
	}
	mock.lockPut.Lock()
	mock.calls.Put = append(mock.calls.Put, callInfo)
	mock.lockPut.Unlock()
	return mock.PutFunc(ctx, key, data)
}

// PutCalls gets all the calls that were made to Put.
// Check the length with:
//
//	len(mockedStorageAdapter.PutCalls())
func (mock *StorageAdapterMock) PutCalls() []struct {
	Ctx  context.Context
	Key  string
	Data []byte
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Data []byte
	}
	mock.lockPut.RLock()
	calls = mock.calls.Put
	mock.lockPut.RUnlock()
	return calls
}
