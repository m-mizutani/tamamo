package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"log/slog"

	"github.com/99designs/gqlgen/graphql"
	goerr "github.com/m-mizutani/goerr/v2"
	"github.com/m-mizutani/tamamo/pkg/controller/auth"
	"github.com/m-mizutani/tamamo/pkg/domain/model/agent"
	graphql1 "github.com/m-mizutani/tamamo/pkg/domain/model/graphql"
	"github.com/m-mizutani/tamamo/pkg/domain/model/slack"
	"github.com/m-mizutani/tamamo/pkg/domain/model/user"
	"github.com/m-mizutani/tamamo/pkg/domain/types"
)

// CreateAgent is the resolver for the createAgent field.
func (r *mutationResolver) CreateAgent(ctx context.Context, input graphql1.CreateAgentInput) (*graphql1.Agent, error) {
	// Validate LLM provider and model if factory is available
	if r.llmFactory != nil && r.llmFactory.GetConfig() != nil {
		provider := convertLLMProviderToString(input.LlmProvider)
		if !r.llmFactory.GetConfig().ValidateProviderModel(provider, input.LlmModel) {
			return nil, goerr.New("invalid LLM provider/model combination",
				goerr.V("provider", provider),
				goerr.V("model", input.LlmModel))
		}
	}

	req := convertCreateAgentInputToRequest(input)

	agent, err := r.agentUseCase.CreateAgent(ctx, req)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to create agent")
	}

	// Get the agent with its latest version for the response
	agentWithVersion, err := r.agentUseCase.GetAgent(ctx, agent.ID)
	if err != nil {
		// Although the agent was created, we can't return the full response.
		// This might indicate a problem, so returning an error is appropriate.
		return nil, goerr.Wrap(err, "failed to retrieve newly created agent with version")
	}

	return convertAgentToGraphQL(ctx, agentWithVersion.Agent, agentWithVersion.LatestVersion, r.userUseCase), nil
}

// UpdateAgent is the resolver for the updateAgent field.
func (r *mutationResolver) UpdateAgent(ctx context.Context, id string, input graphql1.UpdateAgentInput) (*graphql1.Agent, error) {
	agentID := types.UUID(id)
	if !agentID.IsValid() {
		return nil, goerr.New("invalid agent ID")
	}

	// Validate LLM provider and model if provided and factory is available
	if r.llmFactory != nil && r.llmFactory.GetConfig() != nil &&
		input.LlmProvider != nil && input.LlmModel != nil {
		provider := convertLLMProviderToString(*input.LlmProvider)
		if !r.llmFactory.GetConfig().ValidateProviderModel(provider, *input.LlmModel) {
			return nil, goerr.New("invalid LLM provider/model combination",
				goerr.V("provider", provider),
				goerr.V("model", *input.LlmModel))
		}
	}

	req := convertUpdateAgentInputToRequest(input)

	agent, err := r.agentUseCase.UpdateAgent(ctx, agentID, req)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to update agent",
			goerr.V("agent_id", agentID),
			goerr.V("request", req))
	}

	// Get the latest version for the response
	agentWithVersion, err := r.agentUseCase.GetAgent(ctx, agent.ID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get agent with version")
	}

	return convertAgentToGraphQL(ctx, agent, agentWithVersion.LatestVersion, r.userUseCase), nil
}

// DeleteAgent is the resolver for the deleteAgent field.
func (r *mutationResolver) DeleteAgent(ctx context.Context, id string) (bool, error) {
	agentID := types.UUID(id)
	if !agentID.IsValid() {
		return false, goerr.New("invalid agent ID")
	}

	err := r.agentUseCase.DeleteAgent(ctx, agentID)
	if err != nil {
		return false, goerr.Wrap(err, "failed to delete agent")
	}

	return true, nil
}

// ArchiveAgent is the resolver for the archiveAgent field.
func (r *mutationResolver) ArchiveAgent(ctx context.Context, id string) (*graphql1.Agent, error) {
	agentID := types.UUID(id)
	if !agentID.IsValid() {
		return nil, goerr.New("invalid agent ID")
	}

	agentWithVersion, err := r.agentUseCase.ArchiveAgent(ctx, agentID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to archive agent")
	}

	return convertAgentToGraphQL(ctx, agentWithVersion.Agent, agentWithVersion.LatestVersion, r.userUseCase), nil
}

// UnarchiveAgent is the resolver for the unarchiveAgent field.
func (r *mutationResolver) UnarchiveAgent(ctx context.Context, id string) (*graphql1.Agent, error) {
	agentID := types.UUID(id)
	if !agentID.IsValid() {
		return nil, goerr.New("invalid agent ID")
	}

	agentWithVersion, err := r.agentUseCase.UnarchiveAgent(ctx, agentID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to unarchive agent")
	}

	return convertAgentToGraphQL(ctx, agentWithVersion.Agent, agentWithVersion.LatestVersion, r.userUseCase), nil
}

// CreateAgentVersion is the resolver for the createAgentVersion field.
func (r *mutationResolver) CreateAgentVersion(ctx context.Context, input graphql1.CreateAgentVersionInput) (*graphql1.AgentVersion, error) {
	// Validate LLM provider and model if factory is available
	if r.llmFactory != nil && r.llmFactory.GetConfig() != nil {
		provider := convertLLMProviderToString(input.LlmProvider)
		if !r.llmFactory.GetConfig().ValidateProviderModel(provider, input.LlmModel) {
			return nil, goerr.New("invalid LLM provider/model combination",
				goerr.V("provider", provider),
				goerr.V("model", input.LlmModel))
		}
	}

	req := convertCreateAgentVersionInputToRequest(input)

	version, err := r.agentUseCase.CreateAgentVersion(ctx, req)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to create agent version")
	}

	return convertAgentVersionToGraphQL(version), nil
}

// UploadAgentImage is the resolver for the uploadAgentImage field.
func (r *mutationResolver) UploadAgentImage(ctx context.Context, agentID string, file graphql.Upload) (*graphql1.Agent, error) {
	// Validate agent ID
	uuid := types.UUID(agentID)
	if !uuid.IsValid() {
		return nil, goerr.New("invalid agent ID")
	}

	// Verify agent exists
	_, err := r.agentUseCase.GetAgent(ctx, uuid)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to verify agent exists")
	}

	// Get file size
	fileSize := file.Size

	// Process and store the image
	_, err = r.imageProcessor.ProcessAndStore(ctx, uuid, file.File, file.ContentType, fileSize)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to process and store image")
	}

	// Get updated agent with image
	agentWithVersion, err := r.agentUseCase.GetAgent(ctx, uuid)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get updated agent")
	}

	return convertAgentToGraphQL(ctx, agentWithVersion.Agent, agentWithVersion.LatestVersion, r.userUseCase), nil
}

// UpdateDefaultLlm is the resolver for the updateDefaultLLM field.
func (r *mutationResolver) UpdateDefaultLlm(ctx context.Context, provider string, model string) (*graphql1.LLMConfig, error) {
	// This would typically update a configuration file or database
	// For now, we return an error as this requires persistent storage implementation
	return nil, goerr.New("updateDefaultLLM not yet implemented - requires persistent configuration storage")
}

// UpdateFallbackLlm is the resolver for the updateFallbackLLM field.
func (r *mutationResolver) UpdateFallbackLlm(ctx context.Context, enabled bool, provider *string, model *string) (*graphql1.LLMConfig, error) {
	// This would typically update a configuration file or database
	// For now, we return an error as this requires persistent storage implementation
	return nil, goerr.New("updateFallbackLLM not yet implemented - requires persistent configuration storage")
}

// InitiateJiraOAuth is the resolver for the initiateJiraOAuth field.
func (r *mutationResolver) InitiateJiraOAuth(ctx context.Context) (*graphql1.JiraOAuthURL, error) {
	// Get current user from context
	user := getCurrentUser(ctx)
	if user == nil {
		return nil, goerr.New("authentication required")
	}

	// Get HTTP response writer from context (needed for setting cookies)
	w := getResponseWriter(ctx)
	if w == nil {
		return nil, goerr.New("HTTP response writer not available")
	}

	// Initiate OAuth flow
	authURL, err := r.jiraUseCases.InitiateOAuth(ctx, w, user.ID.String())
	if err != nil {
		return nil, goerr.Wrap(err, "failed to initiate OAuth flow")
	}

	return &graphql1.JiraOAuthURL{
		URL: authURL,
	}, nil
}

// DisconnectJira is the resolver for the disconnectJira field.
func (r *mutationResolver) DisconnectJira(ctx context.Context) (bool, error) {
	// Get current user from context
	user := getCurrentUser(ctx)
	if user == nil {
		return false, goerr.New("authentication required")
	}

	// Disconnect Jira integration
	if err := r.jiraUseCases.Disconnect(ctx, user.ID.String()); err != nil {
		return false, goerr.Wrap(err, "failed to disconnect Jira integration")
	}

	return true, nil
}

// InitiateNotionOAuth is the resolver for the initiateNotionOAuth field.
func (r *mutationResolver) InitiateNotionOAuth(ctx context.Context) (*graphql1.NotionOAuthURL, error) {
	// Get current user from context
	user := getCurrentUser(ctx)
	if user == nil {
		return nil, goerr.New("authentication required")
	}

	// Get HTTP response writer from context (needed for setting cookies)
	w := getResponseWriter(ctx)
	if w == nil {
		return nil, goerr.New("HTTP response writer not available")
	}

	// Initiate OAuth flow
	authURL, err := r.notionUseCases.InitiateOAuth(ctx, w, user.ID.String())
	if err != nil {
		return nil, goerr.Wrap(err, "failed to initiate OAuth flow")
	}

	return &graphql1.NotionOAuthURL{
		URL: authURL,
	}, nil
}

// DisconnectNotion is the resolver for the disconnectNotion field.
func (r *mutationResolver) DisconnectNotion(ctx context.Context) (bool, error) {
	// Get current user from context
	user := getCurrentUser(ctx)
	if user == nil {
		return false, goerr.New("authentication required")
	}

	// Disconnect Notion integration
	if err := r.notionUseCases.Disconnect(ctx, user.ID.String()); err != nil {
		return false, goerr.Wrap(err, "failed to disconnect Notion integration")
	}

	return true, nil
}

// CreateSlackSearchConfig is the resolver for the createSlackSearchConfig field.
func (r *mutationResolver) CreateSlackSearchConfig(ctx context.Context, input graphql1.CreateSlackSearchConfigInput) (*graphql1.AgentSlackSearchConfig, error) {
	config, err := r.slackSearchConfigUseCases.CreateSlackSearchConfig(ctx, input.AgentID, input.ChannelID, input.ChannelName, input.Description, input.Enabled)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to create Slack search config")
	}
	return convertSlackSearchConfigToGraphQL(config), nil
}

// UpdateSlackSearchConfig is the resolver for the updateSlackSearchConfig field.
func (r *mutationResolver) UpdateSlackSearchConfig(ctx context.Context, id string, input graphql1.UpdateSlackSearchConfigInput) (*graphql1.AgentSlackSearchConfig, error) {
	config, err := r.slackSearchConfigUseCases.UpdateSlackSearchConfig(ctx, id, input.ChannelName, input.Description, input.Enabled)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to update Slack search config")
	}
	return convertSlackSearchConfigToGraphQL(config), nil
}

// DeleteSlackSearchConfig is the resolver for the deleteSlackSearchConfig field.
func (r *mutationResolver) DeleteSlackSearchConfig(ctx context.Context, id string) (bool, error) {
	err := r.slackSearchConfigUseCases.DeleteSlackSearchConfig(ctx, id)
	if err != nil {
		return false, goerr.Wrap(err, "failed to delete Slack search config")
	}
	return true, nil
}

// CreateJiraSearchConfig is the resolver for the createJiraSearchConfig field.
func (r *mutationResolver) CreateJiraSearchConfig(ctx context.Context, input graphql1.CreateJiraSearchConfigInput) (*graphql1.AgentJiraSearchConfig, error) {
	config, err := r.jiraSearchConfigUseCases.CreateJiraSearchConfig(ctx, input.AgentID, input.ProjectKey, input.ProjectName, input.BoardID, input.BoardName, input.Description, input.Enabled)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to create Jira search config")
	}
	return convertJiraSearchConfigToGraphQL(config), nil
}

// UpdateJiraSearchConfig is the resolver for the updateJiraSearchConfig field.
func (r *mutationResolver) UpdateJiraSearchConfig(ctx context.Context, id string, input graphql1.UpdateJiraSearchConfigInput) (*graphql1.AgentJiraSearchConfig, error) {
	config, err := r.jiraSearchConfigUseCases.UpdateJiraSearchConfig(ctx, id, input.ProjectName, input.BoardID, input.BoardName, input.Description, input.Enabled)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to update Jira search config")
	}
	return convertJiraSearchConfigToGraphQL(config), nil
}

// DeleteJiraSearchConfig is the resolver for the deleteJiraSearchConfig field.
func (r *mutationResolver) DeleteJiraSearchConfig(ctx context.Context, id string) (bool, error) {
	err := r.jiraSearchConfigUseCases.DeleteJiraSearchConfig(ctx, id)
	if err != nil {
		return false, goerr.Wrap(err, "failed to delete Jira search config")
	}
	return true, nil
}

// CreateNotionSearchConfig is the resolver for the createNotionSearchConfig field.
func (r *mutationResolver) CreateNotionSearchConfig(ctx context.Context, input graphql1.CreateNotionSearchConfigInput) (*graphql1.AgentNotionSearchConfig, error) {
	config, err := r.notionSearchConfigUseCases.CreateNotionSearchConfig(ctx, input.AgentID, input.DatabaseID, input.DatabaseName, input.WorkspaceID, input.Description, input.Enabled)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to create Notion search config")
	}
	return convertNotionSearchConfigToGraphQL(config), nil
}

// UpdateNotionSearchConfig is the resolver for the updateNotionSearchConfig field.
func (r *mutationResolver) UpdateNotionSearchConfig(ctx context.Context, id string, input graphql1.UpdateNotionSearchConfigInput) (*graphql1.AgentNotionSearchConfig, error) {
	config, err := r.notionSearchConfigUseCases.UpdateNotionSearchConfig(ctx, id, input.DatabaseName, input.WorkspaceID, input.Description, input.Enabled)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to update Notion search config")
	}
	return convertNotionSearchConfigToGraphQL(config), nil
}

// DeleteNotionSearchConfig is the resolver for the deleteNotionSearchConfig field.
func (r *mutationResolver) DeleteNotionSearchConfig(ctx context.Context, id string) (bool, error) {
	err := r.notionSearchConfigUseCases.DeleteNotionSearchConfig(ctx, id)
	if err != nil {
		return false, goerr.Wrap(err, "failed to delete Notion search config")
	}
	return true, nil
}

// Thread is the resolver for the thread field.
func (r *queryResolver) Thread(ctx context.Context, id string) (*slack.Thread, error) {
	threadID := types.ThreadID(id)
	if !threadID.IsValid() {
		return nil, goerr.New("invalid thread ID")
	}

	thread, err := r.threadRepo.GetThread(ctx, threadID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get thread")
	}

	return thread, nil
}

// Threads is the resolver for the threads field.
func (r *queryResolver) Threads(ctx context.Context, offset *int, limit *int) (*graphql1.ThreadsResponse, error) {
	// Set default values for pagination
	actualOffset := 0
	if offset != nil && *offset > 0 {
		actualOffset = *offset
	}

	actualLimit := 50 // Default page size
	if limit != nil && *limit > 0 {
		// Cap maximum limit to prevent abuse
		if *limit > 1000 {
			actualLimit = 1000
		} else {
			actualLimit = *limit
		}
	}

	// Get threads from repository
	threads, totalCount, err := r.threadRepo.ListThreads(ctx, actualOffset, actualLimit)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to list threads")
	}

	return &graphql1.ThreadsResponse{
		Threads:    threads,
		TotalCount: totalCount,
	}, nil
}

// Agent is the resolver for the agent field.
func (r *queryResolver) Agent(ctx context.Context, id string) (*graphql1.Agent, error) {
	agentID := types.UUID(id)
	if !agentID.IsValid() {
		return nil, goerr.New("invalid agent ID")
	}

	agentWithVersion, err := r.agentUseCase.GetAgent(ctx, agentID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get agent")
	}

	// DEBUG: Log the agent's ImageID
	slog.Debug("GraphQL Agent query - retrieved agent",
		slog.String("agent_id", agentWithVersion.Agent.ID.String()),
		slog.String("agent_name", agentWithVersion.Agent.Name),
		slog.Any("image_id", agentWithVersion.Agent.ImageID))

	return convertAgentToGraphQL(ctx, agentWithVersion.Agent, agentWithVersion.LatestVersion, r.userUseCase), nil
}

// AgentByAgentID is the resolver for the agentByAgentId field.
func (r *queryResolver) AgentByAgentID(ctx context.Context, agentID string) (*graphql1.Agent, error) {
	panic(fmt.Errorf("not implemented: AgentByAgentID - agentByAgentId"))
}

// Agents is the resolver for the agents field.
func (r *queryResolver) Agents(ctx context.Context, offset *int, limit *int) (*graphql1.AgentListResponse, error) {
	// Set default values for pagination
	actualOffset := 0
	if offset != nil && *offset > 0 {
		actualOffset = *offset
	}

	actualLimit := 50 // Default page size
	if limit != nil && *limit > 0 {
		// Cap maximum limit to prevent abuse
		if *limit > 1000 {
			actualLimit = 1000
		} else {
			actualLimit = *limit
		}
	}

	// Get agents from use case
	response, err := r.agentUseCase.ListAgents(ctx, actualOffset, actualLimit)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to list agents")
	}

	// Convert to GraphQL format
	graphqlAgents := make([]*graphql1.Agent, 0, len(response.Agents))
	for _, agentWithVersion := range response.Agents {
		graphqlAgents = append(graphqlAgents, convertAgentToGraphQL(ctx, agentWithVersion.Agent, agentWithVersion.LatestVersion, r.userUseCase))
	}

	return &graphql1.AgentListResponse{
		Agents:     graphqlAgents,
		TotalCount: response.TotalCount,
	}, nil
}

// AllAgents is the resolver for the allAgents field.
func (r *queryResolver) AllAgents(ctx context.Context, offset *int, limit *int) (*graphql1.AgentListResponse, error) {
	// Set default values for pagination
	actualOffset := 0
	if offset != nil && *offset > 0 {
		actualOffset = *offset
	}

	actualLimit := 50 // Default page size
	if limit != nil && *limit > 0 {
		// Cap maximum limit to prevent abuse
		if *limit > 1000 {
			actualLimit = 1000
		} else {
			actualLimit = *limit
		}
	}

	// Get all agents from use case
	response, err := r.agentUseCase.ListAllAgents(ctx, actualOffset, actualLimit)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to list all agents")
	}

	// Convert to GraphQL format
	graphqlAgents := make([]*graphql1.Agent, 0, len(response.Agents))
	for _, agentWithVersion := range response.Agents {
		graphqlAgents = append(graphqlAgents, convertAgentToGraphQL(ctx, agentWithVersion.Agent, agentWithVersion.LatestVersion, r.userUseCase))
	}

	return &graphql1.AgentListResponse{
		Agents:     graphqlAgents,
		TotalCount: response.TotalCount,
	}, nil
}

// AgentsByStatus is the resolver for the agentsByStatus field.
func (r *queryResolver) AgentsByStatus(ctx context.Context, status graphql1.AgentStatus, offset *int, limit *int) (*graphql1.AgentListResponse, error) {
	// Convert GraphQL status to domain status
	var domainStatus agent.Status
	switch status {
	case graphql1.AgentStatusActive:
		domainStatus = agent.StatusActive
	case graphql1.AgentStatusArchived:
		domainStatus = agent.StatusArchived
	default:
		return nil, goerr.New("invalid agent status", goerr.V("status", status))
	}

	// Set default values for pagination
	actualOffset := 0
	if offset != nil && *offset > 0 {
		actualOffset = *offset
	}

	actualLimit := 50 // Default page size
	if limit != nil && *limit > 0 {
		// Cap maximum limit to prevent abuse
		if *limit > 1000 {
			actualLimit = 1000
		} else {
			actualLimit = *limit
		}
	}

	// Get agents by status from use case
	response, err := r.agentUseCase.ListAgentsByStatus(ctx, domainStatus, actualOffset, actualLimit)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to list agents by status",
			goerr.V("status", status),
			goerr.V("offset", actualOffset),
			goerr.V("limit", actualLimit))
	}

	// Convert to GraphQL format
	graphqlAgents := make([]*graphql1.Agent, 0, len(response.Agents))
	for _, agentWithVersion := range response.Agents {
		graphqlAgents = append(graphqlAgents, convertAgentToGraphQL(ctx, agentWithVersion.Agent, agentWithVersion.LatestVersion, r.userUseCase))
	}

	return &graphql1.AgentListResponse{
		Agents:     graphqlAgents,
		TotalCount: response.TotalCount,
	}, nil
}

// AgentVersions is the resolver for the agentVersions field.
func (r *queryResolver) AgentVersions(ctx context.Context, agentUUID string) ([]*graphql1.AgentVersion, error) {
	panic(fmt.Errorf("not implemented: AgentVersions - agentVersions"))
}

// CheckAgentIDAvailability is the resolver for the checkAgentIdAvailability field.
func (r *queryResolver) CheckAgentIDAvailability(ctx context.Context, agentID string) (*graphql1.AgentIDAvailability, error) {
	availability, err := r.agentUseCase.CheckAgentIDAvailability(ctx, agentID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to check agent ID availability")
	}

	return &graphql1.AgentIDAvailability{
		Available: availability.Available,
		Message:   availability.Message,
	}, nil
}

// AgentImage is the resolver for the agentImage field.
func (r *queryResolver) AgentImage(ctx context.Context, id string) (*graphql1.AgentImage, error) {
	imageID := types.UUID(id)
	if !imageID.IsValid() {
		return nil, goerr.New("invalid image ID")
	}

	agentImage, err := r.agentImageRepo.GetByID(ctx, imageID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get agent image")
	}

	return convertAgentImageToGraphQL(agentImage), nil
}

// AgentImageByAgentID is the resolver for the agentImageByAgentId field.
func (r *queryResolver) AgentImageByAgentID(ctx context.Context, agentID string) (*graphql1.AgentImage, error) {
	uuid := types.UUID(agentID)
	if !uuid.IsValid() {
		return nil, goerr.New("invalid agent ID")
	}

	// Get agent first to find the current image ID
	agentWithVersion, err := r.agentUseCase.GetAgent(ctx, uuid)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get agent")
	}

	// Check if agent has an image
	if agentWithVersion.Agent.ImageID == nil {
		return nil, goerr.New("agent has no image")
	}

	// Get agent image using the image ID from agent
	agentImage, err := r.agentImageRepo.GetByID(ctx, *agentWithVersion.Agent.ImageID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get agent image")
	}

	return convertAgentImageToGraphQL(agentImage), nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*user.User, error) {
	userID := types.UserID(id)
	if !userID.IsValid() {
		return nil, goerr.New("invalid user ID")
	}

	u, err := r.userUseCase.GetUserByID(ctx, userID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get user")
	}

	return u, nil
}

// CurrentUser is the resolver for the currentUser field.
func (r *queryResolver) CurrentUser(ctx context.Context) (*user.User, error) {
	session, ok := auth.UserFromContext(ctx)
	if !ok {
		// Not authenticated, or in anonymous mode.
		return nil, nil
	}

	u, err := r.userUseCase.GetUserByID(ctx, session.UserID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get current user")
	}

	return u, nil
}

// LlmConfig is the resolver for the llmConfig field.
func (r *queryResolver) LlmConfig(ctx context.Context) (*graphql1.LLMConfig, error) {
	if r.llmFactory == nil || r.llmFactory.GetConfig() == nil {
		return nil, goerr.New("LLM configuration not available")
	}

	config := r.llmFactory.GetConfig()

	// Convert domain config to GraphQL config
	var providers []*graphql1.LLMProviderInfo
	for id, provider := range config.Providers {
		var models []*graphql1.LLMModel
		for _, model := range provider.Models {
			models = append(models, &graphql1.LLMModel{
				ID:          model.ID,
				DisplayName: model.DisplayName,
				Description: model.Description,
			})
		}

		providers = append(providers, &graphql1.LLMProviderInfo{
			ID:          id,
			DisplayName: provider.DisplayName,
			Models:      models,
		})
	}

	return &graphql1.LLMConfig{
		Providers:        providers,
		DefaultProvider:  config.Defaults.Provider,
		DefaultModel:     config.Defaults.Model,
		FallbackEnabled:  config.Fallback.Enabled,
		FallbackProvider: config.Fallback.Provider,
		FallbackModel:    config.Fallback.Model,
	}, nil
}

// JiraIntegration is the resolver for the jiraIntegration field.
func (r *queryResolver) JiraIntegration(ctx context.Context) (*graphql1.JiraIntegration, error) {
	// Get current user from context
	user := getCurrentUser(ctx)
	if user == nil {
		return nil, goerr.New("authentication required")
	}

	// Get Jira integration from use case
	jiraIntegration, err := r.jiraUseCases.GetIntegration(ctx, user.ID.String())
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get Jira integration")
	}

	// Convert to GraphQL response
	return convertJiraIntegrationToGraphQL(jiraIntegration), nil
}

// NotionIntegration is the resolver for the notionIntegration field.
func (r *queryResolver) NotionIntegration(ctx context.Context) (*graphql1.NotionIntegration, error) {
	// Get current user from context
	user := getCurrentUser(ctx)
	if user == nil {
		return nil, goerr.New("authentication required")
	}

	// Get Notion integration from use case
	notionIntegration, err := r.notionUseCases.GetIntegration(ctx, user.ID.String())
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get Notion integration")
	}

	// Convert to GraphQL response
	return convertNotionIntegrationToGraphQL(notionIntegration), nil
}

// AgentSlackSearchConfigs is the resolver for the agentSlackSearchConfigs field.
func (r *queryResolver) AgentSlackSearchConfigs(ctx context.Context, agentID string) ([]*graphql1.AgentSlackSearchConfig, error) {
	configs, err := r.slackSearchConfigUseCases.GetSlackSearchConfigs(ctx, agentID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get Slack search configs")
	}
	return convertSlackSearchConfigsToGraphQL(configs), nil
}

// AgentJiraSearchConfigs is the resolver for the agentJiraSearchConfigs field.
func (r *queryResolver) AgentJiraSearchConfigs(ctx context.Context, agentID string) ([]*graphql1.AgentJiraSearchConfig, error) {
	configs, err := r.jiraSearchConfigUseCases.GetJiraSearchConfigs(ctx, agentID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get Jira search configs")
	}
	return convertJiraSearchConfigsToGraphQL(configs), nil
}

// AgentNotionSearchConfigs is the resolver for the agentNotionSearchConfigs field.
func (r *queryResolver) AgentNotionSearchConfigs(ctx context.Context, agentID string) ([]*graphql1.AgentNotionSearchConfig, error) {
	configs, err := r.notionSearchConfigUseCases.GetNotionSearchConfigs(ctx, agentID)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get Notion search configs")
	}
	return convertNotionSearchConfigsToGraphQL(configs), nil
}

// ID is the resolver for the id field.
func (r *threadResolver) ID(ctx context.Context, obj *slack.Thread) (string, error) {
	return string(obj.ID), nil
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *user.User) (string, error) {
	return obj.ID.String(), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Thread returns ThreadResolver implementation.
func (r *Resolver) Thread() ThreadResolver { return &threadResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type threadResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
